#pragma once
#include <iostream>
#include <functional>
using namespace std;
/*
    在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。工厂模式作为一种创建模式，一般在创建复杂对象时，考虑使用；
    在创建简单对象时，建议直接new完成一个实例对象的创建。
*/
/*测试简单工厂模式*/
void test_simple_factory_mode();

/*测试工厂方法模式*/
void test_factory_mode();

/*测试抽象工厂模式*/
void test_abstract_factory_mode();

/*
    策略模式是指定义一系列的算法，把它们单独封装起来，并且使它们可以互相替换，使得算法可以独立于使用它的客户端而变化，也是说这些算法所完成的功能类型是一样的，对外接口也是一样的，
    只是不同的策略为引起环境角色环境角色表现出不同的行为。

    相比于使用大量的if...else，使用策略模式可以降低复杂度，使得代码更容易维护。

    缺点：可能需要定义大量的策略类，并且这些策略类都要提供给客户端。

    [环境角色]  持有一个策略类的引用，最终给客户端调用。
*/
/*测试传统策略模式*/
void test_strategy_mode();

/*测试使用函数指针实现策略模式*/
void test_strategy_by_funcction_mode();

/*
    适配器模式可以将一个类的接口转换成客户端希望的另一个接口，使得原来由于接口不兼容而不能在一起工作的那些类可以在一起工作。通俗的讲就是当我们已经有了一些类，而这些类不能满足新的需求，
    此时就可以考虑是否能将现有的类适配成可以满足新需求的类。适配器类需要继承或依赖已有的类，实现想要的目标接口。

    缺点：过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，
    可以不使用适配器，而是直接对系统进行重构。
*/
/*测试组合适配器模式*/
void test_adapter_comb_mode();


/*测试继承适配器模式*/
void test_adapter_derive_mode();